"""Implementation of the `rename-from-log` CLI command."""

from __future__ import annotations

from dataclasses import replace
from pathlib import Path

import click
import typer
from recozik_services.cli_support.deps import get_config_module
from recozik_services.cli_support.locale import apply_locale, resolve_template
from recozik_services.cli_support.options import resolve_option
from recozik_services.cli_support.paths import resolve_path
from recozik_services.cli_support.prompts import (
    prompt_interactive_interrupt_decision,
    prompt_match_selection,
    prompt_rename_interrupt_decision,
    prompt_yes_no,
)
from recozik_services.rename import (
    RenamePrompts as ServiceRenamePrompts,
)
from recozik_services.rename import (
    RenameRequest as ServiceRenameRequest,
)
from recozik_services.rename import (
    RenameServiceError,
)
from recozik_services.rename import (
    rename_from_log as rename_service,
)

from recozik_core.i18n import _

from ._callbacks import TyperCallbacks


class _TyperRenamePrompts(ServiceRenamePrompts):
    """Bridge service-layer prompts to Typer helpers."""

    def yes_no(self, message: str, *, default: bool = True, require_answer: bool = False) -> bool:
        try:
            return prompt_yes_no(message, default=default, require_answer=require_answer)
        except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
            raise KeyboardInterrupt from None

    def select_match(self, matches: list[dict], source_path: Path) -> int | None:
        try:
            return prompt_match_selection(matches, source_path)
        except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
            raise KeyboardInterrupt from None

    def interactive_interrupt_decision(self, has_planned: bool) -> str:
        return prompt_interactive_interrupt_decision(has_planned)

    def rename_interrupt_decision(self, remaining: int) -> str:
        return prompt_rename_interrupt_decision(remaining)


def _handle_log_cleanup(resolved_log: Path, mode: str) -> None:
    valid_modes = {"ask", "always", "never"}
    normalized = mode if mode in valid_modes else "ask"

    def delete_log_file() -> None:
        try:
            resolved_log.unlink()
        except FileNotFoundError:
            typer.echo(_("Log file already removed: {path}").format(path=resolved_log))
        except OSError as exc:
            typer.echo(
                _("Unable to delete log file {path}: {error}").format(path=resolved_log, error=exc)
            )
        else:
            typer.echo(_("Log file deleted: {path}").format(path=resolved_log))

    if not resolved_log.exists():
        typer.echo(_("Log file already removed: {path}").format(path=resolved_log))
        return

    if normalized == "always":
        delete_log_file()
        return

    if normalized == "never":
        typer.echo(_("Log file kept: {path}").format(path=resolved_log))
        return

    while True:
        try:
            if prompt_yes_no(
                _("Delete the log file {path}?").format(path=resolved_log),
                default=False,
                require_answer=True,
            ):
                delete_log_file()
            else:
                typer.echo(_("Log file kept: {path}").format(path=resolved_log))
            break
        except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
            typer.echo(_("Operation cancelled; log file kept."))
            break


def rename_from_log(
    ctx: typer.Context,
    log_path: Path = typer.Argument(
        ...,
        help=_("JSONL log generated by `identify-batch`."),
    ),
    root: Path | None = typer.Option(
        None,
        "--root",
        help=_("Root directory containing the files to rename (defaults to the log directory)."),
    ),
    template: str | None = typer.Option(
        None,
        "--template",
        help=_("Rename template ({artist}, {title}, {album}, {score}, ...)."),
    ),
    require_template_fields: bool | None = typer.Option(
        None,
        "--require-template-fields/--allow-missing-template-fields",
        help=_("Skip matches missing values required by the rename template."),
    ),
    dry_run: bool | None = typer.Option(
        None,
        "--dry-run/--apply",
        help=_(
            "Preview rename operations only (default, configurable). Use --apply to commit changes."
        ),
    ),
    interactive: bool | None = typer.Option(
        None,
        "--interactive/--no-interactive",
        help=_("Offer an interactive choice when multiple matches are available."),
    ),
    confirm: bool | None = typer.Option(
        None,
        "--confirm/--no-confirm",
        help=_("Ask for confirmation before renaming each file."),
    ),
    on_conflict: str = typer.Option(
        "append",
        "--on-conflict",
        help=_("Collision handling strategy: append (default), skip, overwrite."),
    ),
    backup_dir: Path | None = typer.Option(
        None,
        "--backup-dir",
        help=_("Directory where originals are copied before renaming (optional)."),
    ),
    export_path: Path | None = typer.Option(
        None,
        "--export",
        help=_("Path to a JSON file summarising the planned renames."),
    ),
    metadata_fallback: bool | None = typer.Option(
        None,
        "--metadata-fallback/--no-metadata-fallback",
        help=_("Use embedded metadata when no proposal is available."),
    ),
    metadata_fallback_confirm: bool = typer.Option(
        True,
        "--metadata-fallback-confirm/--metadata-fallback-no-confirm",
        help=_("Confirm renames based on embedded metadata (use --metadata-fallback-no-confirm)."),
    ),
    deduplicate_template: bool | None = typer.Option(
        None,
        "--deduplicate-template/--keep-template-duplicates",
        help=_("Collapse matches that would lead to the same target filename."),
    ),
    log_cleanup: str | None = typer.Option(
        None,
        "--log-cleanup",
        help=_("Log cleanup strategy after applying renames: ask (default), always, or never."),
    ),
    config_path: Path | None = typer.Option(
        None,
        "--config-path",
        hidden=True,
        help=_("Custom configuration file path (tests)."),
    ),
) -> None:
    """Rename files using a JSONL log generated by `identify-batch`."""
    apply_locale(ctx)
    config_module = get_config_module()

    resolved_log = resolve_path(log_path)
    root_path = resolve_path(root) if root else resolved_log.parent

    try:
        config = config_module.load_config(config_path)
    except RuntimeError as exc:
        typer.echo(str(exc))
        raise typer.Exit(code=1) from exc

    apply_locale(ctx, config=config)

    template_value = resolve_template(template, config)
    require_template_fields_enabled = (
        config.rename_require_template_fields
        if require_template_fields is None
        else require_template_fields
    )

    conflict_choice = resolve_option(
        ctx,
        "on_conflict",
        on_conflict,
        config.rename_conflict_strategy,
    )

    conflict_strategy = conflict_choice.lower()
    if conflict_strategy not in {"append", "skip", "overwrite"}:
        typer.echo(_("Invalid --on-conflict value. Choose append, skip, or overwrite."))
        raise typer.Exit(code=1)

    metadata_fallback_enabled = (
        config.metadata_fallback_enabled if metadata_fallback is None else metadata_fallback
    )

    dry_run_value = config.rename_default_mode == "dry-run" if dry_run is None else dry_run
    interactive_value = config.rename_default_interactive if interactive is None else interactive
    confirm_value = config.rename_default_confirm_each if confirm is None else confirm

    metadata_fallback_confirm_value = resolve_option(
        ctx,
        "metadata_fallback_confirm",
        metadata_fallback_confirm,
        config.rename_metadata_confirm,
    )

    deduplicate_template_enabled = resolve_option(
        ctx,
        "deduplicate_template",
        deduplicate_template,
        config.rename_deduplicate_template,
        transform=lambda value: bool(value),
    )

    valid_cleanup_modes = {"ask", "always", "never"}
    raw_cleanup_value = resolve_option(
        ctx,
        "log_cleanup",
        log_cleanup,
        getattr(config, "rename_log_cleanup", "ask"),
    )
    cleanup_choice = (raw_cleanup_value or "").strip().lower() or None
    if log_cleanup is not None and cleanup_choice not in valid_cleanup_modes:
        typer.echo(_("Invalid --log-cleanup value. Choose ask, always, or never."))
        raise typer.Exit(code=1)

    config_cleanup = str(getattr(config, "rename_log_cleanup", "ask") or "ask").strip().lower()
    cleanup_mode = cleanup_choice or config_cleanup
    if cleanup_mode not in valid_cleanup_modes:
        cleanup_mode = "ask"

    backup_path = resolve_path(backup_dir) if backup_dir else None

    service_request = ServiceRenameRequest(
        log_path=resolved_log,
        root=root_path,
        template=template_value,
        require_template_fields=require_template_fields_enabled,
        dry_run=dry_run_value,
        interactive=interactive_value,
        confirm_each=confirm_value,
        on_conflict=conflict_strategy,
        backup_dir=backup_path,
        export_path=export_path,
        metadata_fallback=metadata_fallback_enabled,
        metadata_fallback_confirm=metadata_fallback_confirm_value,
        deduplicate_template=deduplicate_template_enabled,
    )

    prompts = _TyperRenamePrompts()
    callbacks = TyperCallbacks(use_stderr=False, warning_stderr=False)

    try:
        summary = rename_service(service_request, callbacks=callbacks, prompts=prompts)
    except RenameServiceError as exc:
        typer.echo(str(exc))
        raise typer.Exit(code=1) from exc

    final_summary = summary

    if summary.dry_run and not summary.interrupted and summary.planned > 0 and summary.plan_entries:
        while True:
            try:
                apply_now = prompt_yes_no(
                    _("Apply the planned renames now?"),
                    default=False,
                    require_answer=True,
                )
                break
            except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
                decision = prompt_interactive_interrupt_decision(summary.planned > 0)
                if decision == "cancel":
                    typer.echo(_("Operation cancelled; no files renamed."))
                    raise typer.Exit(code=1) from None
                if decision == "apply":
                    apply_now = True
                    break
                continue

        if apply_now:
            apply_request = replace(
                service_request,
                dry_run=False,
                preplanned_entries=summary.plan_entries,
            )
            try:
                final_summary = rename_service(apply_request, callbacks=callbacks, prompts=prompts)
            except RenameServiceError as exc:
                typer.echo(str(exc))
                raise typer.Exit(code=1) from exc
        else:
            typer.echo(_("Use --apply to run the renames."))
            return

    if not final_summary.dry_run and not final_summary.interrupted and final_summary.applied > 0:
        _handle_log_cleanup(resolved_log, cleanup_mode)

    if final_summary.interrupted:
        raise typer.Exit(code=1)
