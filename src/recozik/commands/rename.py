"""Implementation of the `rename-from-log` CLI command."""

from __future__ import annotations

import json
import shutil
from pathlib import Path

import click
import typer

from ..cli_support.deps import get_config_module
from ..cli_support.locale import apply_locale, resolve_template
from ..cli_support.logs import load_jsonl_log, render_log_template
from ..cli_support.metadata import build_metadata_match, coerce_metadata_dict
from ..cli_support.paths import (
    compute_backup_path,
    resolve_conflict_path,
    resolve_path,
    sanitize_filename,
)
from ..cli_support.prompts import (
    prompt_interactive_interrupt_decision,
    prompt_match_selection,
    prompt_rename_interrupt_decision,
    prompt_yes_no,
)
from ..i18n import _


def rename_from_log(
    ctx: typer.Context,
    log_path: Path = typer.Argument(
        ...,
        help=_("JSONL log generated by `identify-batch`."),
    ),
    root: Path | None = typer.Option(
        None,
        "--root",
        help=_("Root directory containing the files to rename (defaults to the log directory)."),
    ),
    template: str | None = typer.Option(
        None,
        "--template",
        help=_("Rename template ({artist}, {title}, {album}, {score}, ...)."),
    ),
    dry_run: bool = typer.Option(
        True,
        "--dry-run/--apply",
        help=_("Preview rename operations only (default). Use --apply to commit changes."),
    ),
    interactive: bool = typer.Option(
        False,
        "--interactive/--no-interactive",
        help=_("Offer an interactive choice when multiple matches are available."),
    ),
    confirm: bool = typer.Option(
        False,
        "--confirm/--no-confirm",
        help=_("Ask for confirmation before renaming each file."),
    ),
    on_conflict: str = typer.Option(
        "append",
        "--on-conflict",
        help=_("Collision handling strategy: append (default), skip, overwrite."),
    ),
    backup_dir: Path | None = typer.Option(
        None,
        "--backup-dir",
        help=_("Directory where originals are copied before renaming (optional)."),
    ),
    export_path: Path | None = typer.Option(
        None,
        "--export",
        help=_("Path to a JSON file summarising the planned renames."),
    ),
    metadata_fallback: bool | None = typer.Option(
        None,
        "--metadata-fallback/--no-metadata-fallback",
        help=_("Use embedded metadata when no proposal is available."),
    ),
    metadata_fallback_confirm: bool = typer.Option(
        True,
        "--metadata-fallback-confirm/--metadata-fallback-no-confirm",
        help=_("Confirm renames based on embedded metadata (use --metadata-fallback-no-confirm)."),
    ),
    config_path: Path | None = typer.Option(
        None,
        "--config-path",
        hidden=True,
        help=_("Custom configuration file path (tests)."),
    ),
) -> None:
    """Rename files using a JSONL log generated by `identify-batch`."""
    apply_locale(ctx)
    config_module = get_config_module()

    resolved_log = resolve_path(log_path)
    if not resolved_log.is_file():
        typer.echo(_("Log file not found: {path}").format(path=resolved_log))
        raise typer.Exit(code=1)

    root_path = resolve_path(root) if root else resolved_log.parent

    try:
        config = config_module.load_config(config_path)
    except RuntimeError as exc:
        typer.echo(str(exc))
        raise typer.Exit(code=1) from exc

    apply_locale(ctx, config=config)

    template_value = resolve_template(template, config)
    conflict_strategy = on_conflict.lower()
    if conflict_strategy not in {"append", "skip", "overwrite"}:
        typer.echo(_("Invalid --on-conflict value. Choose append, skip, or overwrite."))
        raise typer.Exit(code=1)

    metadata_fallback_enabled = (
        config.metadata_fallback_enabled if metadata_fallback is None else metadata_fallback
    )

    try:
        entries = load_jsonl_log(resolved_log)
    except ValueError as exc:
        typer.echo(str(exc))
        raise typer.Exit(code=1) from exc

    if not entries:
        typer.echo(_("No entries found in the log."))
        return

    backup_path = resolve_path(backup_dir) if backup_dir else None
    if backup_path:
        backup_path.mkdir(parents=True, exist_ok=True)

    planned: list[tuple[Path, Path, dict]] = []
    export_entries: list[dict] = []
    occupied: set[Path] = set()
    skipped = 0
    errors = 0
    apply_after_interrupt = False

    for entry in entries:
        raw_path = entry.get("path")
        if not raw_path:
            errors += 1
            typer.echo(_("Entry without a path: skipped."))
            continue

        source_path = Path(raw_path)
        if not source_path.is_absolute():
            source_path = (root_path / source_path).resolve()

        if not source_path.exists():
            errors += 1
            typer.echo(_("File not found, skipped: {path}").format(path=source_path))
            continue

        status = entry.get("status")
        error_message = entry.get("error")
        note = entry.get("note")

        matches = entry.get("matches") or []
        metadata_entry = coerce_metadata_dict(entry.get("metadata"))

        if status == "unmatched" and not matches:
            if metadata_fallback_enabled and metadata_entry:
                typer.echo(
                    _("No AcoustID match for {path}, using embedded metadata.").format(
                        path=source_path
                    )
                )
                matches = [build_metadata_match(metadata_entry)]
            else:
                skipped += 1
                context = f" ({note})" if note else ""
                typer.echo(
                    _("No proposal for: {path}{context}").format(path=source_path, context=context)
                )
                continue

        if error_message:
            if matches:
                skipped += 1
                typer.echo(
                    _("Entry with error, skipped: {path} ({error})").format(
                        path=source_path, error=error_message
                    )
                )
                continue
            if metadata_fallback_enabled and metadata_entry:
                typer.echo(
                    _("No AcoustID match for {path}, using embedded metadata.").format(
                        path=source_path
                    )
                )
                matches = [build_metadata_match(metadata_entry)]
                error_message = None
            else:
                skipped += 1
                typer.echo(
                    _("Entry with error, skipped: {path} ({error})").format(
                        path=source_path, error=error_message
                    )
                )
                continue

        if not matches:
            if metadata_fallback_enabled and metadata_entry:
                typer.echo(
                    _("No AcoustID match for {path}, using embedded metadata.").format(
                        path=source_path
                    )
                )
                matches = [build_metadata_match(metadata_entry)]
            else:
                skipped += 1
                typer.echo(_("No proposal for: {path}").format(path=source_path))
                continue

        selected_match_index = 0
        if interactive and len(matches) > 1:
            while True:
                try:
                    selected_match_index = prompt_match_selection(matches, source_path)
                except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
                    decision = prompt_interactive_interrupt_decision(bool(planned))
                    if decision == "cancel":
                        typer.echo(_("Operation cancelled; no files renamed."))
                        raise typer.Exit(code=1) from None
                    if decision == "apply":
                        apply_after_interrupt = True
                        break
                    continue
                else:
                    break

            if apply_after_interrupt:
                break

            if selected_match_index is None:
                skipped += 1
                typer.echo(
                    _("No selection made for {name}; skipping.").format(name=source_path.name)
                )
                continue

        match_data = matches[selected_match_index]
        is_metadata_match = match_data.get("source") == "metadata"
        target_base = render_log_template(match_data, template_value, source_path)
        sanitized = sanitize_filename(target_base)
        if not sanitized:
            sanitized = source_path.stem

        ext = source_path.suffix
        new_name = sanitized
        if ext and not new_name.lower().endswith(ext.lower()):
            new_name = f"{new_name}{ext}"

        target_path = source_path.with_name(new_name)
        if target_path == source_path:
            skipped += 1
            typer.echo(_("Already named correctly: {name}").format(name=source_path.name))
            continue

        final_target = resolve_conflict_path(
            target_path,
            source_path,
            conflict_strategy,
            occupied,
            dry_run,
        )

        if final_target is None:
            skipped += 1
            typer.echo(
                _("Unresolved collision, file skipped: {name}").format(name=source_path.name)
            )
            continue

        metadata_confirmation_done = False

        if is_metadata_match and metadata_fallback_confirm:
            question = _("Confirm rename based on embedded metadata: {source} -> {target}?").format(
                source=source_path.name, target=final_target.name
            )
            skip_current = False
            while True:
                try:
                    if not prompt_yes_no(question, default=True):
                        skip_current = True
                        break
                    metadata_confirmation_done = True
                    break
                except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
                    decision = prompt_interactive_interrupt_decision(bool(planned))
                    if decision == "cancel":
                        typer.echo(_("Operation cancelled; no files renamed."))
                        raise typer.Exit(code=1) from None
                    if decision == "apply":
                        apply_after_interrupt = True
                        break
                    continue

            if apply_after_interrupt:
                break

            if skip_current:
                skipped += 1
                typer.echo(
                    _("Metadata-based rename skipped for {name}.").format(name=source_path.name)
                )
                continue

        if confirm and not metadata_confirmation_done:
            question = _("Rename {source} -> {target}?").format(
                source=source_path.name,
                target=final_target.name,
            )
            skip_current = False
            while True:
                try:
                    if not prompt_yes_no(question, default=True):
                        skip_current = True
                        break
                    break
                except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
                    decision = prompt_interactive_interrupt_decision(bool(planned))
                    if decision == "cancel":
                        typer.echo(_("Operation cancelled; no files renamed."))
                        raise typer.Exit(code=1) from None
                    if decision == "apply":
                        apply_after_interrupt = True
                        break
                    continue

            if apply_after_interrupt:
                break

            if skip_current:
                skipped += 1
                typer.echo(_("Rename skipped for {name}").format(name=source_path.name))
                continue

        planned.append((source_path, final_target, match_data))
        occupied.add(final_target)

    if not planned:
        typer.echo(
            _("No rename performed ({skipped} skipped, {errors} errors).").format(
                skipped=skipped, errors=errors
            )
        )
        return

    if apply_after_interrupt and planned:
        typer.echo(_("Continuing with renames confirmed before the interruption."))

    def execute_planned(run_dry_run: bool) -> tuple[int, bool, list[dict]]:
        renamed_count = 0
        index = 0
        interrupted = False
        entries: list[dict] = []

        while index < len(planned):
            source_path, target_path, match_data = planned[index]
            action = _("DRY-RUN") if run_dry_run else _("RENAMED")
            typer.echo(
                _("{action}: {source} -> {target}").format(
                    action=action,
                    source=source_path,
                    target=target_path,
                )
            )

            if run_dry_run:
                entries.append(
                    {
                        "source": str(source_path),
                        "target": str(target_path),
                        "applied": False,
                        "match": match_data,
                    }
                )
                index += 1
                continue

            try:
                target_path.parent.mkdir(parents=True, exist_ok=True)

                if backup_path:
                    backup_file = compute_backup_path(source_path, root_path, backup_path)
                    backup_file.parent.mkdir(parents=True, exist_ok=True)
                    shutil.copy2(source_path, backup_file)

                if target_path.exists() and conflict_strategy == "overwrite":
                    target_path.unlink()

                source_path.rename(target_path)
            except KeyboardInterrupt:
                decision = prompt_rename_interrupt_decision(len(planned) - index)
                if decision == "continue":
                    typer.echo(_("Continuing renaming."))
                    continue

                interrupted = True
                typer.echo(
                    _(
                        "Renaming interrupted; {completed} file(s) already renamed, "
                        "{remaining} file(s) left untouched."
                    ).format(
                        completed=renamed_count,
                        remaining=len(planned) - index,
                    )
                )
                break

            renamed_count += 1
            entries.append(
                {
                    "source": str(source_path),
                    "target": str(target_path),
                    "applied": True,
                    "match": match_data,
                }
            )
            index += 1

        return renamed_count, interrupted, entries

    renamed_count, interrupted_during_rename, export_entries = execute_planned(dry_run)

    if dry_run and not interrupted_during_rename:
        typer.echo(
            _(
                "Dry-run complete: {planned} potential renames, {skipped} skipped, {errors} errors."
            ).format(planned=len(planned), skipped=skipped, errors=errors)
        )

        while True:
            try:
                apply_now = prompt_yes_no(
                    _("Apply the planned renames now?"),
                    default=False,
                    require_answer=True,
                )
                break
            except (typer.Abort, KeyboardInterrupt, click.exceptions.Abort):
                typer.echo(_("Operation cancelled; no files renamed."))
                return

        if apply_now:
            dry_run = False
            renamed_count, interrupted_during_rename, export_entries = execute_planned(False)
        else:
            typer.echo(_("Use --apply to run the renames."))

    if not dry_run and not interrupted_during_rename:
        typer.echo(
            _("Renaming complete: {renamed} file(s), {skipped} skipped, {errors} errors.").format(
                renamed=renamed_count, skipped=skipped, errors=errors
            )
        )

    if export_path and export_entries:
        resolved_export = resolve_path(export_path)
        resolved_export.parent.mkdir(parents=True, exist_ok=True)
        resolved_export.write_text(
            json.dumps(export_entries, ensure_ascii=False, indent=2),
            encoding="utf-8",
        )
        typer.echo(_("Summary written to {path}").format(path=resolved_export))

    if interrupted_during_rename:
        raise typer.Exit(code=1)
